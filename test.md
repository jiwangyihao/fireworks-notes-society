---
title: test
---

# Web开发

## HTML+CSS+JavaScript：**Vanilla.js香草**

这是一个愚人节笑话

## JQuery：纯粹的JS框架

革新了DOM交互方式，附带了一系列的Utils

## BootStrap：第一个UI框架

提供了一系列的样式组件以及革命式的多列设计系统，第一个响应式框架

## Angular：第一个JS-UI框架

首个提出组件概念的框架

组件是一个伟大的概念：它将逻辑和UI结合成了有机的整体，他允许你打包复用逻辑和UI的集合

## React：最受欢迎的前端框架

首个提出JSX开发范式的框架

尽管Angular首个提出了组件的概念，JSX首个回答了：我们应该怎样把逻辑和UI混在一起开发

——组件就是一个能返回HTML模板的函数

:::tip 什么是纯函数？
纯函数就是不产生副作用的函数

**什么是副作用？**

对于一个函数来说，根据参数，进行一定的运算，返回一个值，就是它原本的职责

在返回值之外，对外界的所有变更，就叫副作用

更进一步的说，纯函数就是没有状态的函数
:::

## Vue：第二受欢迎的前端框架

独创了一个新的回答：SFC——单文件组件

React其实只解决了HTML和JavaScript怎么混在一起开发的问题，他没有解决样式开发的问题

SFC的模式是，我们回到原始的HTML+CSS+JavaScript的模式上，同时，我们摒弃原有的“关注点分离”的开发范式

:::tip 什么叫关注点分离？
我们在不同的文件中编写不同的语言
:::

我们不以语言作为区分代码文件的方式，我们“请循其本”，我们按照实际的功能模块来区分我们的代码文件

也就是说，我们按照实际的功能划分来组织文件，不因为他们是不同的语言，我们就把它分散到不同的位置

```vue :line-numbers
<script setup>
import { ref } from 'vue'
const greeting = ref('Hello World!')
</script>

<template>
  <p class="greeting">{{ greeting }}</p>
</template>

<style>
.greeting {
  color: red;
  font-weight: bold;
}
</style>
```

## Svelte：塞满了语法糖的杂交框架

为了**易用**，我们可以把设计原则放在一边

## CSS框架/原子化CSS框架

### TailwindCSS

#### Before：类名表示元素的角色，样式依据类名来组织

#### After：一个原子化类，就是一个样式

### UnoCSS

### 问题：优先级

在过去，我们在CSS里开发的时候，很自然

style>CSS文件，选择器有自己的优先级

大体上相同优先级的时候，按顺序覆盖，也就后书写的代码覆盖先书写的代码

#### 对于原子化框架

在原子化框架里，所有的样式都是原子化类，它们被生成的位置一样，它们选择器的特定性一样

我们怎么解决谁该覆盖谁的问题

# 从SPA到SSR再到SSG

## 什么是SPA？

SPA是单页应用程序的意思，在JS-UI框架大行其道的背景下，我们发现，我们可以完全让JS接管页面的路由，这大大增加了不同页面之间复用代码的容易程度

### 它有什么问题？

1. SPA程序，搜索引擎爬虫不友好：实际上所有的页面内容，都在一个超级大的JS里面，而早期的搜索引擎爬虫并不能理解这个JS

2. 首屏加载问题：尽管页面切换的时候加载的内容少了，但是，它需要加载所有相关的JS文件，并且等待JS在浏览器上重建DOM结构，才能加载出画面

3. URL的问题：SPA使用了一种很聪明的方法，让你以为它的URL看起来和普通的差不多，但其实不是 [https://mirrors.hit.edu.cn/#/home](https://mirrors.hit.edu.cn/#/home) 中间有一个#号，这个其实是用来索引页面元素的，SPA借用了这个符号，这会破坏原生的特性

第三个问题最好解决：只要我们去掉#号就可以了——Web标准提供了一种，不用刷新也能修改地址栏URL的方法

但这还有个问题：这个URL地址其实没有文件怎么办？

答案是：我们修改服务端的配置，让所有路径的请求，都路由到index.html就好了

这个技术叫做伪静态

## SSR：服务端渲染（Server-side Rendering）

我们在服务端使用和前端的JS-UI框架相同的方法，提前建立对应框架可能会建立的真实DOM结构，并且把它快照到HTML文件中，也就是说，我们在服务器上预先完成原本在浏览器上的可能会很耗时间的DOM渲染过程

当浏览器加载HTML的时候，浏览器可以直接显示服务器上渲染好的HTML，等JS框架加载完毕后，它会重新建立虚拟DOM，并重新建立真实HTML浏览器加载后的DOM与虚拟DOM之间的映射，这个过程叫做水合hydration

## SSR与全栈框架

既然我们已经把前端渲染的一部分工作放到后端了，或者说，既然我们已经有一个后端程序，并且它的工作是前端渲染了

为什么，我们不直接把后端的其他工作也放到这个程序里呢？

这就是全栈框架——事实上差不多所有的SSR框架都是全栈框架

### Nuxt——Vue生态的全栈框架

### Next.js——React生态的全栈框架

...and so on

## 如果……这个网站其实没有什么动态数据，我们在服务端预渲染的片段能不能更进一步，直接让他就是静态的呢——SSG（Static Site Generator）

我们会发现，其实只要**SSR的产物检查一下，去掉所有的动态成分——它就是静态的**

那么这样一个静态的页面（其实，SPA的产物也可以认为是纯静态的），就可以很好地被Serve

事实上，大多数SSR框架都支持作为SSG使用

另外，还有一些专门的SSG框架——它们通常是从非开发语言，或者说文档语言来生成站点的

比如：**VitePress**

# Web开发与客户端开发/跨平台开发

## 为什么是Web？

Web有一个显而易见的优势：

在过去的很长一段时间里，“上网”都和打开网站这个操作是划等号的

显而易见，智能设备基本上不会不能上网——换句话说，只要有个设备声称自己是智能的，它的首要开发工作就是支持显示网站

所以，现在事实上也是，所有的智能操作系统上，都有至少一个浏览器实现

而且，所有的浏览器，大体上都支持W3标准，规范统一

Web还有另一个前面提到了的优势：

HTML+CSS+JavaScript——最成功的UI开发范式

## 使用Web开发技术进行跨平台开发的朴素模式

### 一）编写一个普通的，在目标设备浏览器上看起来很好的网站，它需要、也可以基本上实现所有与目标系统不产生直接交互的功能

### 二）使用目标设备的原生开发语言，编写一个应用，引入一个浏览器组件——这通常非常简单

### 三）在应用启动的时候，加载你的网站

### 四）在你的应用中，使用目标设备的原生开发语言，实现所有与目标系统需要产生直接交互的功能

### 五）约定一种沟通方式，以允许网站使用你使用原生开发语言开发的功能

## Electron：微软对开源世界的最大贡献

本质上，是一个内置了大量原生系统API的Chromium

## Tauri：Rust生态的跨平台开发框架

Rust的魔怔决定了他要做几件事情：

1. 选择了Rust作为原生开发语言

2. 极致的精简：Tauri选择不在应用中携带一个完整的Chromium，相反，它尽可能地选择使用系统中已有的浏览器组件——在Windows中，它使用EdgeWebView，这也导致了，Tauri开发的应用，不能直接在Windows 7/旧版本的WIndow 10中运行

## Capacitor：移动端开发

## Uni-app

## Taro

## 使用Web技术/Web范式进行原生开发（或者，我们宣称是原生的）

我们还是写JS/TS，还是使用我们熟悉的JS-UI框架，但是

我们使用原生的UI组件，而不是加载一个浏览器来渲染它们

### React Native

# 既然，我们有全栈框架，或者说，作为Web开发者，我们发现后端开发其实不那么难，或者说，其实还挺简单的，那么我们有没有JS后端框架呢？

## 服务端程序的简单实现：Express.js

## 更重的后端框架：Nest.js

## “以人为本”的高性能框架：Elysia.js

# 什么是JavaScript运行时

## 从Node.js开始
